use crate::pool;
use crate::DbError;
use crate::DbResult;
use crate::HelmChartActionEndpoint;
use crate::HelmChartActionsSchema;
use async_diesel::*;
use chrono::prelude::*;
use diesel::prelude::*;
use diesel::QueryDsl;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

table! {
    helm_charts(id) {
        id -> Uuid,
        created_at -> Timestamptz,
        helm_registry_id -> Uuid,
        image_digest -> Varchar,
        image_tag -> Varchar,
        available -> Bool,
        values_ui -> Nullable<Jsonb>,
        actions_schema -> Nullable<Jsonb>,
        features -> Nullable<Jsonb>,
        error -> Nullable<Varchar>,
    }
}

#[derive(Debug, Identifiable, Queryable, Serialize)]
pub struct HelmChart {
    pub id: Uuid,
    pub created_at: DateTime<Utc>,
    pub helm_registry_id: Uuid,
    pub image_digest: String,
    pub image_tag: String,
    pub available: bool,
    pub values_ui: Option<serde_json::Value>,
    pub actions_schema: Option<serde_json::Value>,
    pub features: Option<serde_json::Value>,
    pub error: Option<String>,
}

impl HelmChart {
    pub async fn all() -> DbResult<Vec<Self>> {
        Ok(helm_charts::table.get_results_async(pool()).await?)
    }

    pub async fn find(id: Uuid) -> DbResult<Self> {
        Ok(helm_charts::table.find(id).get_result_async(pool()).await?)
    }

    pub async fn find_by_registry_and_digest(
        registry_id: Uuid,
        image_digest: String,
    ) -> DbResult<Option<Self>> {
        Ok(helm_charts::table
            .filter(helm_charts::helm_registry_id.eq(registry_id))
            .filter(helm_charts::image_digest.eq(image_digest))
            .first_async(pool())
            .await
            .optional()?)
    }

    pub fn actions_schema(&self) -> DbResult<HelmChartActionsSchema> {
        match self.actions_schema.as_ref() {
            Some(value) => match serde_json::from_value::<HelmChartActionsSchema>(value.clone()) {
                Ok(schema) => Ok(schema),
                Err(err) => Err(DbError::HelmChartActionsSchemaParseError(err)),
            },
            None => Err(DbError::HelmChartNoActionsSchema),
        }
    }

    pub fn features(&self) -> DbResult<HelmChartFeatures> {
        Ok(match self.features.as_ref() {
            None => Default::default(),
            Some(value) => serde_json::from_value(value.clone())
                .map_err(DbError::HelmChartFeaturesParsingError)?,
        })
    }
}

fn yes() -> bool {
    true
}

#[derive(Debug, Default, Deserialize)]
pub struct HelmChartFeatures {
    /// When true, values.yaml is injected with an `ingress` section
    /// that matches the structure generated by `helm create`. This
    /// generates the hostname and sets TLS correctly.
    #[serde(default)]
    pub standard_ingress: bool,

    /// Sets an HTTP endpoint that returns a platz_sdk::PlatzStatus
    /// and displayed as part of the deployment page.
    pub status: Option<HelmChartStatusFeature>,

    /// Allow deploying OnePerCluster or Many.
    #[serde(default)]
    pub cardinality: HelmChartCardinality,

    /// Should dependent deployments be reinstalled when this deployment
    /// config/values are updated. This doesn't apply to renames or
    /// moving between clusters which always reinstalls dependencies.
    #[serde(default = "yes")]
    pub reinstall_dependencies: bool,

    /// Paths to inject the node selector to. Node selector is always
    /// added at the values top level `nodeSelector`.
    #[serde(default)]
    pub node_selector_paths: Vec<Vec<String>>,

    /// Same for tolerations
    #[serde(default)]
    pub tolerations_paths: Vec<Vec<String>>,
}

#[derive(Debug, Deserialize)]
pub struct HelmChartStatusFeature {
    pub endpoint: HelmChartActionEndpoint,
    pub path: String,
    pub refresh_interval_secs: u64,
}

#[derive(Debug, Deserialize)]
pub enum HelmChartCardinality {
    Many,
    OnePerCluster,
}

impl Default for HelmChartCardinality {
    fn default() -> Self {
        Self::Many
    }
}

#[derive(Insertable, Deserialize)]
#[table_name = "helm_charts"]
pub struct NewHelmChart {
    pub created_at: DateTime<Utc>,
    pub helm_registry_id: Uuid,
    pub image_digest: String,
    pub image_tag: String,
    pub values_ui: Option<serde_json::Value>,
    pub actions_schema: Option<serde_json::Value>,
    pub features: Option<serde_json::Value>,
    pub error: Option<String>,
}

impl NewHelmChart {
    pub async fn insert(self) -> DbResult<HelmChart> {
        Ok(diesel::insert_into(helm_charts::table)
            .values(self)
            .get_result_async(pool())
            .await?)
    }
}

#[derive(AsChangeset)]
#[table_name = "helm_charts"]
pub struct UpdateHelmChart {
    pub available: Option<bool>,
}

impl UpdateHelmChart {
    pub async fn save(self, id: Uuid) -> DbResult<HelmChart> {
        Ok(diesel::update(helm_charts::table.find(id))
            .set(self)
            .get_result_async(pool())
            .await?)
    }
}
